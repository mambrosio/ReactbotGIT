// Generated by CoffeeScript 1.6.3
(function() {
  var Deferral, Future, Promise, Resolver, isArray, slice, state,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  isArray = require('omicron').isArray;

  state = require('state');

  Future = require('./future');

  Resolver = require('./resolver');

  Promise = require('./promise');

  slice = Array.prototype.slice;

  module.exports = Deferral = (function(_super) {
    var later,
      _this = this;

    __extends(Deferral, _super);

    later = Deferral.later;

    function Deferral() {
      this._callbacks = null;
      this._resolver = null;
      this._promise = null;
      this._context = null;
      this._values = null;
    }

    Deferral.resolverToState = function(stateName) {
      return function() {
        var args, callback, callbacks, queue, _context, _i, _len;
        this.state().go(stateName);
        if (callbacks = this._callbacks) {
          queue = callbacks[stateName];
          this._callbacks = null;
        }
        args = arguments.length ? this._values = slice.call(arguments) : this._values || (this._values = []);
        _context = this._context;
        if (queue != null) {
          try {
            if (isArray(queue)) {
              for (_i = 0, _len = queue.length; _i < _len; _i++) {
                callback = queue[_i];
                callback.apply(_context, args);
              }
            } else {
              queue.apply(_context, args);
            }
          } catch (_error) {}
        }
      };
    };

    Deferral.invokeIff = function(boundStateName) {
      return function(stateName, callback) {
        if (stateName === boundStateName) {
          return later.call(this._context, callback, this._values);
        }
      };
    };

    Deferral.promise = function() {
      return (new this).promise();
    };

    Deferral.prototype.getStateName = function() {
      return this.state().name;
    };

    Deferral.prototype.resolver = function() {
      return this._resolver || (this._resolver = new Resolver(this));
    };

    Deferral.prototype.promise = function() {
      return this._promise || (this._promise = new Promise(this));
    };

    state(Deferral.prototype, 'abstract', {
      as: function() {
        return this;
      },
      given: function() {
        return this;
      },
      unresolved: state('abstract', {
        once: function(stateName, callback) {
          var callbacks, queue;
          callbacks = this._callbacks || (this._callbacks = {});
          if (queue = callbacks[stateName]) {
            if (isArray(queue)) {
              queue.push(callback);
            } else {
              callbacks[stateName] = [queue, callback];
            }
          } else {
            callbacks[stateName] = callback;
          }
        },
        pending: state('initial', (function() {
          var getThenFrom;
          getThenFrom = Deferral.getThenFrom;
          return {
            as: function(_context) {
              this._context = _context;
              return this;
            },
            given: function(values) {
              if (values !== void 0) {
                this._values = values === null ? null : isArray(values) ? values : [values];
              }
              return this;
            },
            accept: Deferral.resolverToState('accepted'),
            reject: Deferral.resolverToState('rejected'),
            resolve: function(value) {
              var error, then_,
                _this = this;
              if (value === this) {
                return this.reject(new TypeError);
              }
              try {
                if (then_ = getThenFrom(value)) {
                  return then_.call(value, function(next) {
                    return (next === value ? _this.accept : _this.resolve).apply(_this, arguments);
                  }, function() {
                    return _this.reject.apply(_this, arguments);
                  });
                }
              } catch (_error) {
                error = _error;
                return this.reject(error);
              }
              return this.accept(value);
            }
          };
        })())
      }),
      resolved: state('conclusive abstract', {
        completed: state('conclusive abstract', {
          accepted: state('final default', {
            once: Deferral.invokeIff('accepted')
          }),
          rejected: state('final', {
            once: Deferral.invokeIff('rejected')
          })
        })
      })
    });

    return Deferral;

  }).call(this, Future);

}).call(this);
